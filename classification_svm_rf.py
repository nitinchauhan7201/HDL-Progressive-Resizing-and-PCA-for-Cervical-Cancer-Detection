# -*- coding: utf-8 -*-
"""classification_svm_rf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L7Skwb_1F563cBZbc8xwVoHg4xr-7FAi
"""

import numpy as np
import h5py
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline

# Define path
base_path = r"C:\Users\nitin\Desktop\Cervical_Cancer_Detection"

# Load data function
def load_data_from_flow(data_flow):
    images, labels = [], []
    for i in range(len(data_flow)):
        img, lbl = data_flow[i]
        images.append(img.flatten())
        labels.append(lbl)
    return np.array(images), np.array(labels)

# Initialize ImageDataGenerator
train_datagen = ImageDataGenerator(
    featurewise_center=False,
    rotation_range=20,
    fill_mode="nearest",
    zoom_range=[1/1.2, 1/1.2],
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True,
    vertical_flip=True,
    brightness_range=[0.4, 1.4],
    channel_shift_range=20
)

DA_IDG = ImageDataGenerator()

# Load data for different resolutions
def get_data_generators(resolution):
    path = f"{base_path}\SIPaKMeD_{resolution}"

    train_gen = train_datagen.flow_from_directory(
        path + "\train",
        target_size=(resolution, resolution),
        color_mode='rgb',
        batch_size=64,
        class_mode='categorical',
        shuffle=True
    )

    val_gen = DA_IDG.flow_from_directory(
        path + "\val",
        target_size=(resolution, resolution),
        color_mode='rgb',
        class_mode='categorical',
        shuffle=True
    )

    test_gen = DA_IDG.flow_from_directory(
        path + "\test",
        target_size=(resolution, resolution),
        color_mode='rgb',
        batch_size=1,
        class_mode='categorical',
        shuffle=False
    )

    return train_gen, val_gen, test_gen

import numpy as np
import h5py
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.metrics import classification_report, accuracy_score
from sklearn.preprocessing import LabelEncoder

# Load data function
def load_data_from_flow(data_flow):
    images, labels = [], []
    for i in range(len(data_flow)):
        img, lbl = data_flow[i]
        images.append(img.flatten())
        labels.append(lbl)
    return np.array(images), np.array(labels)

# Load PCA weights
def load_pca_weights(file_path):
    return np.load(file_path)

# Train and evaluate classifiers
def train_and_evaluate_classifiers(train_data, test_data, pca_weight_file, classifiers):
    X_train, y_train = train_data
    X_test, y_test = test_data

    # Load PCA weights and apply PCA
    pca_weights = load_pca_weights(pca_weight_file)
    pca = PCA(n_components=0.95)
    pca.fit(pca_weights)

    # Transform training and testing data
    X_train_pca = pca.transform(X_train)
    X_test_pca = pca.transform(X_test)

    # Train classifiers
    for clf_name, clf in classifiers.items():
        clf.fit(X_train_pca, y_train)

    # Create majority voting classifier
    voting_clf = VotingClassifier(estimators=[(name, clf) for name, clf in classifiers.items()], voting='soft')
    voting_clf.fit(X_train_pca, y_train)

    # Predict and evaluate
    y_pred = voting_clf.predict(X_test_pca)

    # Generate classification report
    report = classification_report(y_test, y_pred, target_names=test_data[1])
    accuracy = accuracy_score(y_test, y_pred)
    return accuracy, report

# Define classifiers
svm = make_pipeline(StandardScaler(), SVC(probability=True))
rf = RandomForestClassifier()
classifiers = {
    'svm': svm,
    'rf': rf
}

# Load data and apply classifiers for different resolutions
resolutions = {
    '224': 'pca_weights_concatenate_model1.h5.npy',
    '512': 'pca_weights_concatenate_model2.h5.npy',
    '1024': 'pca_weights_concatenate_model3.h5.npy'
}

for res, pca_file in resolutions.items():
    train_gen, _, test_gen = get_data_generators(int(res))
    X_train, y_train = load_data_from_flow(train_gen)
    X_test, y_test = load_data_from_flow(test_gen)

    accuracy, report = train_and_evaluate_classifiers(
        (X_train, y_train),
        (X_test, y_test),
        pca_file,
        classifiers
    )

    print(f'Classification Report for resolution {res}:')
    print(report)
    print(f'Accuracy for resolution {res}: {accuracy:.2f}\n')